/*------------------------------------------------------------------------------*
 *                       (c)2016, All Rights Reserved.     						*
 *       ___           ___           ___     									*
 *      /__/\         /  /\         /  /\    									*
 *      \  \:\       /  /:/        /  /::\   									*
 *       \  \:\     /  /:/        /  /:/\:\  									*
 *   ___  \  \:\   /  /:/  ___   /  /:/~/:/        								*
 *  /__/\  \__\:\ /__/:/  /  /\ /__/:/ /:/___     UCR DMFB Synthesis Framework  *
 *  \  \:\ /  /:/ \  \:\ /  /:/ \  \:\/:::::/     www.microfluidics.cs.ucr.edu	*
 *   \  \:\  /:/   \  \:\  /:/   \  \::/~~~~ 									*
 *    \  \:\/:/     \  \:\/:/     \  \:\     									*
 *     \  \::/       \  \::/       \  \:\    									*
 *      \__\/         \__\/         \__\/    									*
 *-----------------------------------------------------------------------------*/
/*------------------------------Algorithm Details-------------------------------*
 * Type: Pin Mapper																*
 * Name: Power Aware Pin Mapper													*
 *																				*
 * Inferred from the following paper, with modification:						*
 * Authors: Tsung-Wei Huang, Hong-Yan Su, and Tsung-Yi Ho						*
 * Title:Progressive Network-Flow Based Power-Aware Broadcast					*
 * Addressing for Pin-Constrained Digital Microfluidic Biochips					*
 * DAC'11, June 5-10, 2011, San Diego, California, USA							*
 * Copyright © 2011 ACM 978-1-4503-0636-2/11/06									*
 * 																				*
 * Details: This pin mapper uses the pin activations generated by a router in	*
 * order to optimize the number of electrodes that need to be independently		*
 * addressed. In addition, it takes into account how many redundant electrode	*
 * activations are incurred, attempting to minimize redundancy in order to		*
 * conserve power through a flow network. This leads to a reduction in the		*
 * number of pins necessary	to run the particular assay, lower power			*
 * consumption, and hopefully an easier wiring problem for the wire router.		*
 *-----------------------------------------------------------------------------*/

#ifndef POWER_CLIQUE_PIN_MAPPER_H_
#define POWER_CLIQUE_PIN_MAPPER_H_

#include "flow_network_pin_mapper.h"
#include <vector>
/*
class PowerAwarePinMapper : public CliquePinMapper
{
public:

	PowerAwarePinMapper();
	PowerAwarePinMapper(DmfbArch *dmfbArch);
	void setMapPostRoute(vector<vector<int> *> *pinActivations, map<Droplet *, vector<RoutePoint *> *> *routes);
	CliquePinMapper::Graph convertMatrixToGraph(const vector< vector<int> > &matrix);
	Graph convertMatrixToGraph(const int & size);
	vector<vector< string > > convertToCliques(PowerAwarePinMapper::Graph & g);
	vector<string> findAndDeleteMaxClique();
	void setPinMapping(map<string,int> addressedElectrodes, int pinNo);
	void processAndAddressMaxClique(vector<string> max_clique, const vector<vector<int> > & AMatrix);
	vector<int> seqCompare(const vector<int> & s1, const vector<int> & s2);
	int getNumSwitches(const vector<int> & seq);
	void calculateSwitchingResults();
	//int getRAUpi(int pinIdx, int elecIdx, const vector<vector<int> > & AMatrix) const;

	vector<vector<string> > currentPins;
	vector<vector<int> > PinActivationSeqs;
	map<string,int> addressedElectrodes;
	vector<vector<string> > cliques;
	int totalRAU;
};
*/

class PowerAwarePinMapper : public FlowNetworkPinMapper
{
public:

	PowerAwarePinMapper();
	PowerAwarePinMapper(DmfbArch *dmfbArch);
	void setMapPostRoute(vector<vector<int> *> *pinActivations, map<Droplet *, vector<RoutePoint *> *> *routes);


	virtual MinCostMaxFlowGraph constructMCMF();
	virtual void addEdgeBasedOnConstraints(CliquePinMapper::Graph & g, long long seq1index, long long seq2index, string s1, string s2, long long size);
	//int getNumSwitches(const vector<int> & seq);
	//void calculateSwitchingResults();
	int totalRAU;
};

#endif /* POWER_CLIQUE_PIN_MAPPER_H_ */
